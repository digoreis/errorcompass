/*
 * This source file was generated by the Gradle 'init' task
 */
package pt.iscte.errorcompass

import com.github.javaparser.JavaParser
import com.github.javaparser.ParserConfiguration
import com.github.javaparser.ast.CompilationUnit
import com.github.javaparser.symbolsolver.JavaSymbolSolver
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver
import pt.iscte.errorcompass.checkers.*
import pt.iscte.errorcompass.errors.ParseError
import pt.iscte.errorcompass.generates.ErrorGenerator
import pt.iscte.errorcompass.model.ErrorDescription
import pt.iscte.errorcompass.model.ResultAnalyzer
import pt.iscte.errorcompass.support.CompilationItem
import pt.iscte.errorcompass.support.compileNoOutput
import java.io.File
import java.nio.file.Paths

/**
 * ErrorCompass class provides methods to analyze Java code for potential errors.
 * It utilizes various checkers to inspect code quality and identify issues.
 */
class ErrorCompass() {
    /**
     * Runs the evaluation process on a string containing Java code.
     *
     * @param code The Java code as a string to be analyzed.
     * @return Result<ResultAnalyzer> containing the analysis result.
     */
    fun run(code: String): Result<ResultAnalyzer> {
        val generator = ErrorGenerator()
        var errors = emptyList<ErrorDescription>()
        val typeSolver = CombinedTypeSolver()
        typeSolver.add(ReflectionTypeSolver())
        typeSolver.add(JavaParserTypeSolver(Paths.get(".")))
        val symbolSolver = JavaSymbolSolver(typeSolver)
        val parserConfiguration = ParserConfiguration()
        parserConfiguration.setSymbolResolver(symbolSolver)
        val parser = JavaParser(parserConfiguration).parse(code.trimIndent())
        parser.ifSuccessful {
            val variableTypeChecker = VariableTypeChecker(it)
            val returnTypeChecker = MethodReturnChecker()
            val controlStructureChecker = ControlStructureChecker()
            val stringComparisonChecker = StringComparisonChecker()
            val uninitializedVariableChecker = UninitializedVariableChecker()
            //Execute Checker
            variableTypeChecker.visit(it, null)
            returnTypeChecker.visit(it, null)
            controlStructureChecker.visit(it, null)
            stringComparisonChecker.visit(it, null)
            uninitializedVariableChecker.visit(it, null)

            val totalIssues = variableTypeChecker.issues + returnTypeChecker.issues + controlStructureChecker.issues + stringComparisonChecker.issues + uninitializedVariableChecker.issues

            errors = totalIssues.mapNotNull { generator.generate(it) }
        }
        if(!parser.isSuccessful) {
            val diagnostics = compileNoOutput(listOf(CompilationItem(File("Main.java"), code)))
            errors = diagnostics.mapNotNull { generator.generate(it) }
        }

        return Result.success(ResultAnalyzer(errors))
    }

    /**
     * Runs the evaluation process on a file containing Java code.
     *
     * @param file The File object representing the file to be analyzed.
     * @return Result<ResultAnalyzer> containing the analysis result.
     */
    fun run(file: File): Result<ResultAnalyzer> {
        return run(file.readText())
    }
}


